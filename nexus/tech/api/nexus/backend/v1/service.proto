syntax = "proto3";

package nexus.backend.v1;

import "nexus/backend/v1/model.proto";

import "google/api/annotations.proto";

// This service is implemented by Nexus backends to support service registration
// and task handling.
//
// NOTES:
// * This service is all that a Nexus server has to implement to support
//   non-Temporal-specific Nexus SDK code.
// * Technically each of the ~3 things this service does are for a different
//   audience that will be detailed in the NOTES of each. This can be broken up
//   if it'd make sense for a Nexus backend to, say, only support
//   "GetServices" + "Call".
// * Do we need CRUD for mapping outbound endpoint names to their remote service
//   endpoints or can that remain config for now?
service BackendService {
  // Update the set of known services on the backend. This can be used to
  // replace or just add/remove services. The entire call will succeed or fail.
  //
  // NOTES:
  // * User would be a Nexus admin, often via CLI or UI.
  // * This is not to be confused with the mapping for the caller backend of
  //   endpoint names to actual endpoints. Rather this is the receiving backend
  //   service. A service must be created before a Nexus call can be made on it.
  rpc UpdateServices (UpdateServicesRequest) returns (UpdateServicesResponse) {
    option (google.api.http) = {
      post: "/v1/backend/services"
      body: "*"
    };
  }

  // Get all registered services on this backend.
  //
  // NOTES:
  // * User would be any Nexus caller to this backend. This is basically a
  //   discovery endpoint and in the future may have a more proper spec defining
  //   what operations are available.
  // * There are currently no use cases that justify any kind of filtering here.
  rpc GetServices (GetServicesRequest) returns (GetServicesResponse) {
    option (google.api.http) = {
      get: "/v1/backend/services"
    };
  }

  // Make a Nexus call to this backend.
  //
  // NOTES:
  // * User would be any Nexus caller to this backend.
  // * In the from-Temporal-workflow-to-Temporal use case, this would be invoked
  //   by the caller's Temporal server and received/hosted by the callee
  //   Temporal server.
  // * Due to the fact that long-polling for ALO response is supported, this
  //   call does not necessarily have to be short lived (but it should be).
  rpc Call (CallRequest) returns (CallResponse) {
    option (google.api.http) = {
      post: "/v1/backend/call"
      body: "*"
    };
  }

  // Ask for the next Nexus request to process by a worker. This is a long-poll
  // that may be terminated by the backend after a period of time with no
  // request. Workers are often expected to continually ask for requests and are
  // expected to complete requests relatively quickly.
  //
  // NOTES:
  // * User would be a Nexus worker programmatically.
  // * Consideration was given to using a gRPC stream here, but they are hard to
  //   proxy well and in gRPC/HTTP2 there is essentially no overhead to repeated
  //   calls of this nature over a poll. The only benefit of the stream is the
  //   keep-alive ability. Should we consider streams?
  // * Note, there is no cancellation path. Nexus request/response are expected
  //   to be quick. This is not to be confused with an ALO. A Nexus request
  //   would just _start_ an ALO, never hang while it runs.
  rpc PollNexusRequestQueue (PollNexusRequestQueueRequest) returns  (PollNexusRequestQueueResponse) {
    option (google.api.http) = {
      post: "/v1/backend/requests/poll"
      body: "*"
    };
  }

  // Tell the backend the worker has completed the Nexus request.
  //
  // NOTES:
  // * User would be a Nexus worker programmatically.
  // * Unlike workflow/activity task APIs today, this includes failures
  rpc RespondNexusRequestCompleted (RespondNexusRequestCompletedRequest) returns (RespondNexusRequestCompletedResponse) {
    option (google.api.http) = {
      post: "/v1/backend/requests/respond"
      body: "*"
    };
  }
}

message UpdateServicesRequest {
  // Set of services to create or update.
  repeated Service services = 1;

  // If set, the set of services to remove. Cannot have values if replace is
  // true. The update will fail if this includes a service that does not exist.
  repeated string remove_services = 2;

  // If true, will replace all existing services with given services. Cannot be
  // true if remove_services has values.
  //
  // NOTES:
  // * Yes this is technically a scary operation to be able to replace your
  //   services and therefore accidentally delete one. But this is an API, one
  //   would expect a UI/CLI to guard the user more. This simple
  //   single-rpc-mutation API is preferred over multiple mutation methods.
  // * Do we want a conflict_token that is returned in GetServicesResponse for
  //   atomic mutations?
  bool replace = 3;
}

message UpdateServicesResponse {
  // Set of created/updated services. Does not include deleted ones.
  repeated Service services = 1;
}

message GetServicesRequest {
}

message GetServicesResponse {
  repeated Service services = 1;
}

// Values that can be added to each metadata key in the call or response.
// 
// NOTES:
// * This is analogous to HTTP headers (and will map to them when we do the HTTP
//   protocol) which is why it's a set of repeated values.
message MetadataValues {
  repeated string values = 1;
}

enum OperationType {
  OPERATION_TYPE_UNSPECIFIED = 0;
  NORMAL = 1;
  ALO = 2;
}

message CallRequest {
  // Unique, client-supplied identifier for the request. This should be unique
  // for both the caller and the receiver.
  //
  // NOTES:
  // * So, say in a scenario where a user isn't using some good global
  //   uniqueness. Can a completely separate caller use the same request
  //   identifier to cause clash? Ideally, for security purposes each
  //   authenticated caller org is isolated from the other, so the onus is on
  //   the server to qualify this.
  string request_id = 1;

  // Service this call is for.
  //
  // NOTES:
  // * For HTTP this is part of the URL most likely.
  // * For Temporal workflow commands/events this is just a simple name, but for
  //   direct calling clients this is much more than just a name, it is an
  //   endpoint and may need to carry auth in the future. Should we break this
  //   out into a type? Should we stop reusing this CallRequest on the Temporal
  //   side which only needs a simple string?
  string service = 2;

  // Metadata for the operation.
  //
  // NOTES:
  // * For HTTP these are headers. This will include the HTTP2 headers :method,
  //   :scheme, :authority, and :path for all HTTP calls.
  map<string, MetadataValues> metadata = 3;

  // Operation for this call. By convention these are slash-delimited to
  // represent any kind of hierarchy. Some operations are special:
  // 
  // * <alo-operation> - Start ALO, input can be anything, response is always
  //   AloInfo.
  // * <alo-operation>/cancel - Cancel ALO, input must be AloRef, response has
  //   no output.
  // * <alo-operation>/get - Get ALO, input must be AloRef, response is always
  //   AloInfo.
  // * <alo-operation>/wait - Wait for ALO completion, input must be AloRef,
  //   successful response is CallResponse. This can be a long-poll operation
  //   and callers are expected to re-wait if the connection is severed.
  //
  // NOTES:
  // * For HTTP this is part of the URL most likely.
  // * Yes, "<alo-operation>" means that any call _could_ be an ALO, but maybe
  //   not. This poses many challenges on the user. Are we ok with this?
  // * <alo-operation>/wait is the only reason to support long-polling in all of
  //   Nexus. Do we want to make that (or ALO calls in general) more explicit?
  string operation = 4;

  // Input for the operation.
  //
  // NOTES:
  // * For HTTP, this is the body.
  // * We are not handling large, streaming inputs at this time (e.g. streaming
  //   a file upload).
  bytes input = 5;

  // If set and the operation is an ALO (i.e. the response type is ALO_INFO),
  // this is the callback invoked upon completion. If the operation is not an
  // ALO this value is ignored.
  CompletionCallback alo_completion_callback = 6;

  message CompletionCallback {

    // Callback to invoke on ALO completion.
    //
    // NOTES:
    // * Don't need this oneof now (moving top-level into oneof is a backwards
    //   compatible operation), it's just to show we can have other callback
    //   approaches.
    oneof callback {
      Http http = 1;
    }

    // HTTP details for the callback.
    //
    // NOTES:
    // * This obviously lacks any kind of auth details at the moment. Having
    //   said that, users are strongly encouraged to embed one-time-use tokens
    //   into the URL that are authed when received. This allows URLs to survive
    //   authentication rollover.
    // * It is particularly notable that this, in itself, could be a Nexus
    //   endpoint. That may be one (ugly) way to intercept/alter responses.
    message Http {
      // URL to POST the JSON CallResponse POSTed to it.
      string url = 1;
    }
  }

  // NOTES:
  // * We intentionally don't add a timeout on this request for either the
  //   request itself or the full ALO time. Callers are expected to timeout
  //   themselves for the request itself. Callers are expected to cancel an ALO
  //   after their preferred ALO timeout.
  // * In the future we can provide more caller information (addr, TLS, etc).
  // * In the future we can include the protocol the caller is using.
}

message CallResponse {
  // Same unique identifier provided on the request.
  string request_id = 1;

  // Metadata for the operation.
  //
  // NOTES:
  // * For HTTP these are headers. This will include the HTTP2 header :status
  //   for all HTTP calls.
  // * Is there somewhere we want to define an "encoding" for success/failure
  //   output types?
  map<string, MetadataValues> metadata = 2;

  oneof response {
    Success success = 3;

    // Failure of a call. This is NOT validation or eager failure, but rather
    // failure of the underlying implementation.
    //
    // For non-ALO calls and ALO starts, this should probably never be used but
    // instead a gRPC failure should be returned (but clients must be prepared
    // to handle this like a gRPC failure if present).
    //
    // For ALO call completions, this failure is returned from a long-poll wait
    // or sent via callback.
    Failure failure = 4;
  }

  message Success {
    // Type of operation. If this is ALO_INFO, then the output is an AloInfo
    // proto. This can come from starting an ALO or getting an ALO.
    // 
    // NOTES:
    // * Open to clearer ways to represent that the result of an operation is a
    //   start ALO and not just a regular response.
    // * For HTTP, if ALO_INFO, this would also be in a header. Maybe this
    //   should be in metadata anyways?
    ResponseType response_type = 1;
  
    // Output for the operation.
    //
    // NOTES:
    // * For HTTP, this is the body.
    // * We are not handling large, streaming inputs at this time
    //   (e.g. streaming a file upload).
    bytes output = 2;
  
    enum ResponseType {
      RESPONSE_TYPE_UNSPECIFIED = 0;
      ALO_INFO = 1;
    }
  }

  message Failure {
    // Arbitrary user-defined code for failure.
    // 
    // NOTES:
    // * It seems unreasonable to pre-define a set of codes (HTTP status code?
    //   gRPC status code?). But is there value in a generic representation of
    //   certain types of errors? Should we even have this field?
    uint32 code = 1;

    // Error details for the operation.
    //
    // NOTES:
    // * It is understood that opaque error blobs are hard to reason about
    //   generically, but it is important for flexibility. Do we want to be more
    //   strict about error formats? For now, clients must be written to accept
    //   arbitrary types as error output just as they do for success output.
    bytes output = 2;
  }
}

message PollNexusRequestQueueRequest {
  // Services the caller can accept requests for.
  // 
  // NOTES:
  // * This is intentionally not a single service like Temporal has single task
  //   queue which is too limiting.
  // * The reason Service is a message and not just a name is so we can add
  //   things like priority, server labels patterns, operation filters, etc in
  //   the future. This is much more robust than Temporal's current approach.
  repeated ServiceMatch services = 1;

  // Metadata for the poll request.
  //
  // NOTES:
  // * This can include identity, versions, arbitrary labels for server-side
  //   matching, whatever.
  map<string, MetadataValues> metadata = 2;

  message ServiceMatch {
    string name = 1;
  }
}

message PollNexusRequestQueueResponse {
  // Call request.
  // 
  // NOTES:
  // * While we technically could get rid of this response message and just use
  //   CallRequest as response from the RPC, it's not good practice and does not
  //   allow for future expansion of just this response.
  CallRequest request = 1;
}

message RespondNexusRequestCompletedRequest {
  // Call response.
  // 
  // NOTES:
  // * While we technically could get rid of this completed message and just use
  //   CallResponse as request from the RPC, it's not good practice and does not
  //   allow for future expansion of just this request.
  CallResponse response = 1;
}

message RespondNexusRequestCompletedResponse {
}
